# blocks.py

This module implements the core transformer‐based update block and the correlation sampling block used by the track predictor.

## Classes

### `EfficientUpdateFormer`
**Description:**  
A transformer model that refines track estimates by alternating temporal attention over track tokens and optional spatial attention with virtual track tokens.

**Constructor Args:**
- `space_depth` (`int`): Number of spatial attention layers. Set to 0 to disable space attention.
- `time_depth` (`int`): Number of temporal (self-)attention layers.
- `input_dim` (`int`): Dimension of input token embeddings.
- `hidden_size` (`int`): Embedding dimension inside self-attention layers.
- `num_heads` (`int`): Number of attention heads.
- `output_dim` (`int`): Dimension of the final output per token (e.g., 2 for coordinate updates).
- `mlp_ratio` (`float`): Hidden-to-embedding ratio for the internal MLP.
- `add_space_attn` (`bool`): Whether to enable alternating spatial attention via virtual tokens.
- `num_virtual_tracks` (`int`): Number of virtual track tokens for spatial grouping.

**Attributes:**
- `input_norm`: LayerNorm on input tokens.
- `input_transform`: Linear projection to hidden size.
- `time_blocks`: ModuleList of `AttnBlock` for temporal updates.
- `space_virtual_blocks`, `space_point2virtual_blocks`, `space_virtual2point_blocks`: ModuleLists for alternating spatial attention (if enabled).
- `flow_head`: Linear head producing output predictions.

**Methods:**
- `initialize_weights()`: Xavier/truncated normal initialization.
- `forward(input_tensor, mask=None)`: Applies input normalization, projections, runs through temporal (and spatial) blocks, adds residual, applies output normalization and head.

**Forward Args:**
- `input_tensor` (`Tensor[B, N, T, C_in]`): Input track tokens over time.
- `mask` (optional): Attention mask for spatial blocks.

**Returns:**
(flow, None), where `flow` has shape `(B, N, T, output_dim)`.

### `CorrBlock`
**Description:**  
Builds a multi-level correlation pyramid between target features and input feature maps, and samples correlation values in a local neighborhood around predicted coordinates to form a feature vector for each track and time step.

**Constructor Args:**
- `fmaps` (`Tensor[B, S, C, H, W]`): Feature maps for each frame.
- `num_levels` (`int`): Number of pyramid levels (downsampling by factor 2 each).
- `radius` (`int`): Search radius for sampling correlation around each coordinate.
- `multiple_track_feats` (`bool`): Whether to split target features per pyramid level.
- `padding_mode` (`str`): Padding mode passed to sampling (e.g., "zeros" or "border").

**Attributes:**
- `fmaps_pyramid`: List of feature maps at each pyramid level.
- `delta`: Precomputed displacement grid of shape `((2r+1), (2r+1), 2)`.

**Methods:**
- `corr_sample(targets, coords) -> Tensor[B, S, N, L]`: For each target feature and coordinate, samples correlation values from each pyramid level, flattening them to a vector of length `L = num_levels * (2*radius+1)^2`.

## Functions

### `compute_corr_level(fmap1, fmap2s, C)`
**Description:**  
Computes raw dot-product correlation between target features `fmap1` of shape `(B, S, N, C)` and flattened feature maps `fmap2s` of shape `(B, S, C, H*W)`, then scales by `1/√C`.

**Args:**
- `fmap1`: `(B, S, N, C)` target features.
- `fmap2s`: `(B, S, C, H*W)` flattened reference features.
- `C`: Feature dimensionality.

**Returns:**
Tensor of shape `(B, S, N, H*W)` containing scaled correlations.

*Generated by developer documentation script.*